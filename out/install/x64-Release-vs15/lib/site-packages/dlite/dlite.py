# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Python bindings to DLite


"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _dlite
else:
    import _dlite

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _get_DLiteError() -> "PyObject *":
    return _dlite._get_DLiteError()

DLiteError = _dlite._get_DLiteError()


def get_version() -> "char const *":
    r"""
    get_version() -> char const *
    Returns the current version of DLite.

    """
    return _dlite.get_version()

def get_license() -> "char const *":
    r"""
    get_license() -> char const *
    Returns DLite licenses information.

    """
    return _dlite.get_license()

def get_uuid(id: "char const *"=None) -> "char *":
    r"""
    get_uuid(id=None)
    Returns an UUID, depending on:
      - If `id` is NULL or empty, generates a new random version 4 UUID.
      - If `id` is not a valid UUID string, generates a new version 5 sha1-based
        UUID from `id` using the DNS namespace.
      - Otherwise return `id` (which already must be a valid UUID).

    """
    return _dlite.get_uuid(id)

def get_uuid_version(id: "char const *"=None) -> "posstatus_t":
    r"""
    get_uuid_version(id=None) -> posstatus_t
    Returns the generated UUID version number if `id` had been passed to
    get_uuid() or zero if `id` is already a valid UUID.

    """
    return _dlite.get_uuid_version(id)

def join_meta_uri(name: "char const *", version: "char const *", namespace: "char const *") -> "char *":
    r"""
    join_meta_uri(name, version, namespace) -> char *
    Returns a (metadata) uri by combining `name`, `version` and `namespace` as:

        namespace/version/name

    """
    return _dlite.join_meta_uri(name, version, namespace)

def split_meta_uri(uri: "char const *") -> "char **, char **, char **":
    r"""
    split_meta_uri(uri) -> status_t
    Returns (name, version, namespace)-tuplet from valid metadata `uri`.

    """
    return _dlite.split_meta_uri(uri)

def join_url(driver: "char const *", location: "char const *", options: "char const *"=None, fragment: "char const *"=None) -> "char *":
    r"""
    join_url(driver, location, options=None, fragment=None) -> char *
    Returns an url constructed from the arguments of the form:

        driver://location?options#fragment

    The `driver`, `options` and `fragment` arguments may be None.

    """
    return _dlite.join_url(driver, location, options, fragment)

def split_url(url: "char *") -> "char **, char **, char **, char **":
    r"""
    split_url(url) -> status_t
    Returns a (driver, location, options, fragment)-tuplet by splitting
    `url` of the form

        driver://location?options#fragment

    into four parts.

    """
    return _dlite.split_url(url)

def globmatch(pattern: "char const *", s: "char const *") -> "int":
    r"""
    globmatch(pattern, s) -> int
    Match string 's' against glob pattern 'pattern' and return zero on
    match.

    Understands the following patterns:
         *       any number of characters
         ?       any single character
         [a-z]   any single character in the range a-z
         [^a-z]  any single character not in the range a-z

    """
    return _dlite.globmatch(pattern, s)

def errclr() -> "void":
    r"""errclr()"""
    return _dlite.errclr()

def err_get_stream() -> "FILE *":
    r"""err_get_stream() -> FILE *"""
    return _dlite.err_get_stream()

def err_set_stream(arg1: "FILE *") -> "void":
    r"""err_set_stream(arg1)"""
    return _dlite.err_set_stream(arg1)

def err_set_file(filename: "char const *") -> "void":
    r"""
    err_set_file(filename)
    Set error log file.  Special values includes:
      - None | : turn off error output
      - <stderr>:  standard error
      - <stdout>:  standard output
    All other values are treated as a filename that will be opened in append mode.

    """
    return _dlite.err_set_file(filename)

def asbool(str: "char const *") -> "bool":
    r"""
    asbool(str) -> bool
    Set error stream.

    """
    return _dlite.asbool(str)

import dlite

class err():
    """Context manager for temporary turning off or redirecting errors.

    By default errors are skipped within the err context.  But if
    `filename` is provided, the error messages are written to that file.
    Special file names includes
      - None or empty: no output is written
      - <stderr>: write errors to stderr (default)
      - <stdout>: write errors to stdout
    """
    def __init__(self, filename=None):
        self.filename = filename

    def __enter__(self):
        self.f = dlite.err_get_stream()
        dlite.err_set_file(self.filename)
        return self.f

    def __exit__(self, *exc):
        dlite.errclr()
        dlite.err_set_stream(self.f)

silent = err()

BlobType = _dlite.BlobType

BoolType = _dlite.BoolType

IntType = _dlite.IntType

UIntType = _dlite.UIntType

FloatType = _dlite.FloatType

FixStringType = _dlite.FixStringType

StringPtrType = _dlite.StringPtrType

DimensionType = _dlite.DimensionType

PropertyType = _dlite.PropertyType

RelationType = _dlite.RelationType


def from_typename(typename: "char const *") -> "int *, int *":
    r"""from_typename(typename) -> status_t"""
    return _dlite.from_typename(typename)

def to_typename(type: "int", size: "int") -> "char *":
    r"""to_typename(type, size) -> char *"""
    return _dlite.to_typename(type, size)

def get_alignment(type: "int", size: "size_t") -> "size_t":
    r"""get_alignment(type, size) -> size_t"""
    return _dlite.get_alignment(type, size)
class StorageIterator(object):
    r"""
    Iterates over instances in storage `s`.  If `pattern` is given, only
    instances whos metadata URI matches `pattern` are returned.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    s = property(_dlite.StorageIterator_s_get, _dlite.StorageIterator_s_set, doc=r"""s""")
    state = property(_dlite.StorageIterator_state_get, _dlite.StorageIterator_state_set, doc=r"""state""")

    def __init__(self, s: "Storage", pattern: "char const *"=None):
        r"""
        __init__(self, s, pattern=None) -> StorageIterator
        Iterates over instances in storage `s`.  If `pattern` is given, only
        instances whos metadata URI matches `pattern` are returned.

        """
        _dlite.StorageIterator_swiginit(self, _dlite.new_StorageIterator(s, pattern))
    __swig_destroy__ = _dlite.delete_StorageIterator

    def next(self) -> "struct _DLiteInstance *":
        r"""
        next(self) -> Instance
        Returns UUID of next instance or None if exhausted.
        """
        return _dlite.StorageIterator_next(self)

    def __iter__(self) -> "struct StorageIterator *":
        r"""__iter__(self) -> StorageIterator"""
        return _dlite.StorageIterator___iter__(self)

    def __next__(self):
        inst = self.next()
        if not inst:
            raise StopIteration()
        return inst


# Register StorageIterator in _dlite:
_dlite.StorageIterator_swigregister(StorageIterator)

IDTranslateToUUID = _dlite.IDTranslateToUUID

IDRequireUUID = _dlite.IDRequireUUID

IDKeepID = _dlite.IDKeepID

class Storage(object):
    r"""
    Represents a data storage.

    Call signatures
    ---------------
    Storage(driver, location, options)
    Storage(url)

    Parameters
    ----------
    driver : string
        Name of driver used to connect to the storage.
    location : string
        The location to the storage.  For file storages, this is the file name.
        For web-based storages this is the location-part of the url.
    options : string
        Additional options passed to the driver as a list of semicolon-separated
        ``key=value`` pairs.  Each driver may have their own options.  Some
        common options are:
          - mode={'append','r','w'}: 'append': append to existing storage or
            create a new one (hdf5,json).
          - compact={'yes','no'}: Whether to store in a compact format (json).
          - meta={'yes','no'}: Whether to format output as metadata (json).
    url : string
        A combination of `driver`, `location` and `options` in the form

            driver://location?options

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    location = property(_dlite.Storage_location_get, doc=r"""location""")
    options = property(_dlite.Storage_options_get, doc=r"""options""")
    writable = property(_dlite.Storage_writable_get, doc=r"""writable""")
    idflag = property(_dlite.Storage_idflag_get, doc=r"""idflag""")

    def __init__(self, *args):
        r"""
        __init__(self, driver, location, options) -> Storage
        __init__(self, url) -> Storage
        Represents a data storage.

        Call signatures
        ---------------
        Storage(driver, location, options)
        Storage(url)

        Parameters
        ----------
        driver : string
            Name of driver used to connect to the storage.
        location : string
            The location to the storage.  For file storages, this is the file name.
            For web-based storages this is the location-part of the url.
        options : string
            Additional options passed to the driver as a list of semicolon-separated
            ``key=value`` pairs.  Each driver may have their own options.  Some
            common options are:
              - mode={'append','r','w'}: 'append': append to existing storage or
                create a new one (hdf5,json).
              - compact={'yes','no'}: Whether to store in a compact format (json).
              - meta={'yes','no'}: Whether to format output as metadata (json).
        url : string
            A combination of `driver`, `location` and `options` in the form

                driver://location?options

        """
        _dlite.Storage_swiginit(self, _dlite.new_Storage(*args))
    __swig_destroy__ = _dlite.delete_Storage

    def get_driver(self) -> "char const *":
        r"""
        get_driver(self) -> char const *
        Returns name of driver for this storage.
        """
        return _dlite.Storage_get_driver(self)

    def get_uuids(self, pattern: "char const *"=None) -> "char **":
        r"""
        get_uuids(self, pattern=None) -> char **
        Returns a list of UUIDs of all instances in the storage whos metadata
        matches `pattern`.  If `pattern` is None, all UUIDs will be returned.

        """
        return _dlite.Storage_get_uuids(self, pattern)

    def __enter__(self):
        return self

    def __exit__(self, *exc):
        del self.this

    def __repr__(self):
        options = '?%s' % self.options if self.options else ''
        return "Storage('%s://%s%s')" % (self.driver, self.uri, options)

    def __iter__(self):
        return StorageIterator(self)

    def instances(self, pattern=None):
        """Returns an iterator over all instances in storage whos
        metadata URI matches `pattern`."""
        return StorageIterator(pattern)

    def load(self, id, metaid=None):
        """Loads instance `id` from this storage and return it.

        If `metaid` is provided, the returned instance will be
        mapped to an instance of this type (if appropriate mappings
        are available)."""
        return Instance(self, id, metaid)

    def save(self, inst):
        """Stores instance `inst` in this storage."""
        inst.save(self)

    driver = property(get_driver,
                      doc='Name of driver associated with this storage')


# Register Storage in _dlite:
_dlite.Storage_swigregister(Storage)

class StoragePluginIter(object):
    r"""
    Iterates over loaded storage plugins.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iter = property(_dlite.StoragePluginIter_iter_get, _dlite.StoragePluginIter_iter_set, doc=r"""iter""")

    def __init__(self):
        r"""
        __init__(self) -> StoragePluginIter
        Iterates over loaded storage plugins.

        """
        _dlite.StoragePluginIter_swiginit(self, _dlite.new_StoragePluginIter())
    __swig_destroy__ = _dlite.delete_StoragePluginIter

    def next(self) -> "char const *":
        r"""
        next(self) -> char const *
        Returns name of next plugin or None if exhausted.

        """
        return _dlite.StoragePluginIter_next(self)

    def __iter__(self) -> "struct StoragePluginIter *":
        r"""__iter__(self) -> StoragePluginIter"""
        return _dlite.StoragePluginIter___iter__(self)

    def __next__(self):
        name = self.next()
        if not name:
            raise StopIteration()
        return name


# Register StoragePluginIter in _dlite:
_dlite.StoragePluginIter_swigregister(StoragePluginIter)


def storage_unload(name: "char const *") -> "int":
    r"""storage_unload(name) -> int"""
    return _dlite.storage_unload(name)
class Dimension(object):
    r"""Proxy of C _DLiteDimension struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_dlite.Dimension_name_get, _dlite.Dimension_name_set, doc=r"""name""")
    description = property(_dlite.Dimension_description_get, _dlite.Dimension_description_set, doc=r"""description""")

    def __init__(self, name: "char const *", description: "char const *"=None):
        r"""__init__(self, name, description=None) -> Dimension"""
        _dlite.Dimension_swiginit(self, _dlite.new_Dimension(name, description))
    __swig_destroy__ = _dlite.delete_Dimension

    def __repr__(self):
        return 'Dimension(name=%r, description=%r)' % (
            self.name, self.description)

    def asdict(self):
        """Returns a dict representation of self."""
        d = OrderedDict([('name', self.name)])
        if self.description:
            d['description'] = self.description
        return d

    def asstrings(self):
        """Returns a representation of self as a tuple of strings."""
        return (self.name,
                '' if self.description is None else self.description)


# Register Dimension in _dlite:
_dlite.Dimension_swigregister(Dimension)

class Property(object):
    r"""
    Creates a new property.

    Property(name, type, dims=None, unit=None, iri=None, description=None)
        Creates a new property with the provided attributes.

    Property(seq)
        Creates a new property from sequence of 6 strings, corresponding to
        `name`, `type`, `dims`, `unit`, `iri` and `description`.  Valid
        values for `dims` are:
          - '' or '[]': no dimensions
          - '<dim1>, <dim2>': list of dimension names
          - '[<dim1>, <dim2>]': list of dimension names


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_dlite.Property_name_get, _dlite.Property_name_set, doc=r"""name""")
    size = property(_dlite.Property_size_get, _dlite.Property_size_set, doc=r"""size""")
    ndims = property(_dlite.Property_ndims_get, _dlite.Property_ndims_set, doc=r"""ndims""")
    unit = property(_dlite.Property_unit_get, _dlite.Property_unit_set, doc=r"""unit""")
    iri = property(_dlite.Property_iri_get, _dlite.Property_iri_set, doc=r"""iri""")
    description = property(_dlite.Property_description_get, _dlite.Property_description_set, doc=r"""description""")

    def __init__(self, name: "char const *", type: "char const *", dims: "obj_t *"=None, unit: "char const *"=None, iri: "char const *"=None, description: "char const *"=None):
        r"""
        __init__(self, name, type, dims=None, unit=None, iri=None, description=None) -> Property
        Creates a new property.

        Property(name, type, dims=None, unit=None, iri=None, description=None)
            Creates a new property with the provided attributes.

        Property(seq)
            Creates a new property from sequence of 6 strings, corresponding to
            `name`, `type`, `dims`, `unit`, `iri` and `description`.  Valid
            values for `dims` are:
              - '' or '[]': no dimensions
              - '<dim1>, <dim2>': list of dimension names
              - '[<dim1>, <dim2>]': list of dimension names


        """
        _dlite.Property_swiginit(self, _dlite.new_Property(name, type, dims, unit, iri, description))
    __swig_destroy__ = _dlite.delete_Property

    def get_type(self) -> "char *":
        r"""get_type(self) -> char *"""
        return _dlite.Property_get_type(self)

    def get_dtype(self) -> "int":
        r"""get_dtype(self) -> int"""
        return _dlite.Property_get_dtype(self)

    def get_dims(self) -> "obj_t *":
        r"""get_dims(self) -> obj_t *"""
        return _dlite.Property_get_dims(self)

    def __repr__(self):
        dims = ', dims=%r' % self.dims.tolist() if self.ndims else ''
        unit = ', unit=%r' % self.unit if self.unit else ''
        iri = ', iri=%r' % self.iri if self.iri else ''
        descr = ', description=%r' %self.description if self.description else ''
        return 'Property(%r, type=%r%s%s%s%s)' % (
            self.name, self.type, dims, unit, iri, descr)

    def asdict(self):
        """Returns a dict representation of self."""
        d = OrderedDict([('name', self.name),
                         ('type', self.get_type()),
                         ])
        if self.ndims:
            d['dims'] = self.dims.tolist()
        if self.unit:
            d['unit'] = self.unit
        if self.iri:
            d['iri'] = self.iri
        if self.description:
            d['description'] = self.description
        return d

    def asstrings(self):
        """Returns a representation of self as a tuple of strings."""
        return (self.name, self.type, ','.join(str(d) for d in self.dims),
                '' if self.unit is None else self.unit,
                '' if self.iri is None else self.iri,
                '' if self.description is None else self.description)

    type = property(get_type, doc='Type name.')
    dtype = property(get_dtype, doc='Type number.')
    dims = property(get_dims, doc='Array of dimension indices.')


# Register Property in _dlite:
_dlite.Property_swigregister(Property)

class Relation(object):
    r"""Proxy of C _Triple struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    s = property(_dlite.Relation_s_get, _dlite.Relation_s_set, doc=r"""s""")
    p = property(_dlite.Relation_p_get, _dlite.Relation_p_set, doc=r"""p""")
    o = property(_dlite.Relation_o_get, _dlite.Relation_o_set, doc=r"""o""")
    id = property(_dlite.Relation_id_get, _dlite.Relation_id_set, doc=r"""id""")

    def __init__(self, s: "char const *", p: "char const *", o: "char const *", id: "char const *"=None):
        r"""__init__(self, s, p, o, id=None) -> Relation"""
        _dlite.Relation_swiginit(self, _dlite.new_Relation(s, p, o, id))
    __swig_destroy__ = _dlite.delete_Relation

    def __repr__(self):
        return 'Relation(s=%r, p=%r, o=%r, id=%r)' % (
            self.s, self.p, self.o, self.id)

    def aspreferred(self):
        """Returns preferred Python representation."""
        return self.asstrings()

    def asdict(self):
        """Returns a dict representation of self."""
        if self.id:
            d = OrderedDict(s=self.s, p=self.p, o=self.o, id=self.id)
        else:
            d = OrderedDict(s=self.s, p=self.p, o=self.o)
        return d

    def asstrings(self):
        """Returns a representation of self as a tuple of strings."""
        return (self.s, self.p, self.o)


# Register Relation in _dlite:
_dlite.Relation_swigregister(Relation)


def triple_get_id(s: "char const *", p: "char const *", o: "char const *", namespace: "char const *"=None) -> "char *":
    r"""triple_get_id(s, p, o, namespace=None) -> char *"""
    return _dlite.triple_get_id(s, p, o, namespace)

def triple_set_default_namespace(namespace: "char const *") -> "void":
    r"""triple_set_default_namespace(namespace)"""
    return _dlite.triple_set_default_namespace(namespace)
class Instance(object):
    r"""
    Returns a new instance.

    Instance(metaid, dims, id=None)
        Creates a new instance of metadata `metaid`.  `dims` must be a
        sequence with the size of each dimension. All values initialized
        to zero.  If `id` is None, a random UUID is generated.  Otherwise
        the UUID is derived from `id`.

    Instance(url, metaid=NULL)
        Loads the instance from `url`.  The URL should be of the form
        ``driver://location?options#id``.
        If `metaid` is provided, the instance is tried mapped to this
        metadata before it is returned.

    Instance(storage, id=None, metaid=NULL)
        Loads the instance from `storage`. `id` is the id of the instance
        in the storage (not required if the storage only contains more one
        instance).
        If `metaid` is provided, the instance is tried mapped to this
        metadata before it is returned.

    Instance(driver, location, options, id=None)
        Loads the instance from storage specified by `driver`, `location`
        and `options`. `id` is the id of the instance in the storage (not
        required if the storage only contains more one instance).

    Instance(uri, dimensions, properties, iri, description)
        Creates a new metadata entity (instance of entity schema) casted
        to an instance.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    uuid = property(_dlite.Instance_uuid_get, doc=r"""uuid""")
    uri = property(_dlite.Instance_uri_get, doc=r"""uri""")
    _refcount = property(_dlite.Instance__refcount_get, doc=r"""_refcount""")

    def __init__(self, *args):
        r"""
        __init__(self, metaid, dims, id=None) -> Instance
        __init__(self, url, metaid=None) -> Instance
        __init__(self, storage, id=None, metaid=None) -> Instance
        __init__(self, driver, location, options, id=None) -> Instance
        __init__(self, uri, ndimensions, nproperties, iri=None, description=None) -> Instance
        Returns a new instance.

        Instance(metaid, dims, id=None)
            Creates a new instance of metadata `metaid`.  `dims` must be a
            sequence with the size of each dimension. All values initialized
            to zero.  If `id` is None, a random UUID is generated.  Otherwise
            the UUID is derived from `id`.

        Instance(url, metaid=NULL)
            Loads the instance from `url`.  The URL should be of the form
            ``driver://location?options#id``.
            If `metaid` is provided, the instance is tried mapped to this
            metadata before it is returned.

        Instance(storage, id=None, metaid=NULL)
            Loads the instance from `storage`. `id` is the id of the instance
            in the storage (not required if the storage only contains more one
            instance).
            If `metaid` is provided, the instance is tried mapped to this
            metadata before it is returned.

        Instance(driver, location, options, id=None)
            Loads the instance from storage specified by `driver`, `location`
            and `options`. `id` is the id of the instance in the storage (not
            required if the storage only contains more one instance).

        Instance(uri, dimensions, properties, iri, description)
            Creates a new metadata entity (instance of entity schema) casted
            to an instance.


        """
        _dlite.Instance_swiginit(self, _dlite.new_Instance(*args))
    __swig_destroy__ = _dlite.delete_Instance

    def get_meta(self) -> "struct _DLiteInstance const *":
        r"""
        get_meta(self) -> Instance
        Returns reference to metadata.
        """
        return _dlite.Instance_get_meta(self)

    def get_iri(self) -> "char const *":
        r"""
        get_iri(self) -> char const *
        Returns ontology IRI reference.
        """
        return _dlite.Instance_get_iri(self)

    def set_iri(self, iri: "char const *"=None) -> "void":
        r"""
        set_iri(self, iri=None)
        Sets ontology IRI (no argument clears the IRI).
        """
        return _dlite.Instance_set_iri(self, iri)

    def save(self, *args) -> "void":
        r"""
        save(self, url)
        save(self, storage)
        save(self, driver, path, options=None)
        Saves this instance to url or storage.
        """
        return _dlite.Instance_save(self, *args)

    def get_dimensions(self) -> "obj_t *":
        r"""
        get_dimensions(self) -> obj_t *
        Returns array with dimension sizes.
        """
        return _dlite.Instance_get_dimensions(self)

    def get_dimension_size(self, *args) -> "int":
        r"""
        get_dimension_size(self, name) -> int
        get_dimension_size(self, i) -> int
        Returns the size of dimension with given name or index.
        """
        return _dlite.Instance_get_dimension_size(self, *args)

    def get_property(self, *args) -> "obj_t *":
        r"""
        get_property(self, name) -> obj_t
        get_property(self, i) -> obj_t *
        Returns property with given name or index.
        """
        return _dlite.Instance_get_property(self, *args)

    def set_property(self, *args) -> "void":
        r"""
        set_property(self, name, obj)
        set_property(self, i, obj)
        Sets property with given name or index to `obj`.
        """
        return _dlite.Instance_set_property(self, *args)

    def has_property(self, *args) -> "bool":
        r"""
        has_property(self, name) -> bool
        has_property(self, i) -> bool
        Returns true if this instance has a property with given name or index.
        """
        return _dlite.Instance_has_property(self, *args)

    def has_dimension(self, *args) -> "bool":
        r"""
        has_dimension(self, name) -> bool
        has_dimension(self, i) -> bool
        Returns true if this instance has a dimension with given name or index.
        """
        return _dlite.Instance_has_dimension(self, *args)

    def _is_data(self) -> "bool":
        r"""
        _is_data(self) -> bool
        Returns true if this is a data instance.
        """
        return _dlite.Instance__is_data(self)

    def _is_meta(self) -> "bool":
        r"""
        _is_meta(self) -> bool
        Returns true if this is metadata.
        """
        return _dlite.Instance__is_meta(self)

    def _is_metameta(self) -> "bool":
        r"""
        _is_metameta(self) -> bool
        Returns true if this is meta-metadata.
        """
        return _dlite.Instance__is_metameta(self)

    def incref(self) -> "int":
        r"""
        incref(self) -> int
        Increase reference count and return the new refcount.
        """
        return _dlite.Instance_incref(self)

    def decref(self) -> "int":
        r"""
        decref(self) -> int
        Decrease reference count and return the new refcount.
        """
        return _dlite.Instance_decref(self)

    def __len__(self) -> "int":
        r"""__len__(self) -> int"""
        return _dlite.Instance___len__(self)

    def __repr__(self) -> "char *":
        r"""__repr__(self) -> char *"""
        return _dlite.Instance___repr__(self)

    def _c_ptr(self) -> "PyObject *":
        r"""_c_ptr(self) -> PyObject *"""
        return _dlite.Instance__c_ptr(self)

    meta = property(get_meta, doc="Reference to the metadata of this instance.")
    iri = property(get_iri, set_iri,
                   doc="Unique IRI to corresponding concept in an ontology.")
    dimensions = property(
        lambda self: OrderedDict((d.name, int(v))
                                 for d, v in zip(self.meta['dimensions'],
                                                 self.get_dimensions())),
        doc='Dictionary with dimensions name-value pairs.')
    properties = property(lambda self:
        {p.name: self[p.name] for p in self.meta['properties']},
        doc='Dictionary with property name-value pairs.')
    is_data = property(_is_data, doc='Whether this is a data instance.')
    is_meta = property(_is_meta, doc='Whether this is a metadata instance.')
    is_metameta = property(_is_metameta,
                           doc='Whether this is a meta-metadata instance.')

    def __getitem__(self, ind):
        if self.has_property(ind):
            return self.get_property(ind)
        elif isinstance(ind, int):
            raise IndexError('instance property index out of range: %d' % ind)
        else:
            raise KeyError('no such property: %s' % ind)

    def __setitem__(self, ind, value):
        if self.has_property(ind):
            self.set_property(ind, value)
        elif isinstance(ind, int):
            raise IndexError('instance property index out of range: %d' % ind)
        else:
            raise KeyError('no such property: %s' % ind)

    def __contains__(self, item):
        return item in self.properties.keys()

    def __getattr__(self, name):
        if name == 'this':
            return object.__getattribute__(self, name)
        d = object.__getattribute__(self, '__dict__')
        if name in d:
            return d[name]
        elif self.has_property(name):
            return _get_property(self, name)
        elif self.has_dimension(name):
            return self.get_dimension_size(name)
        else:
            raise AttributeError('Instance object has no attribute %r' % name)

    def __setattr__(self, name, value):
        if name == 'this':
            object.__setattr__(self, name, value)
        elif _has_property(self, name):
            _set_property(self, name, value)
        else:
            object.__setattr__(self, name, value)

    def __dir__(self):
        return (object.__dir__(self) +
                [name for name in self.properties] +
                [d.name for d in self.meta.properties['dimensions']])

    def __hash__(self):
        return UUID(self.uuid).int

    def __eq__(self, other):
        return self.uuid == other.uuid

    def __str__(self):
        return self.asjson(indent=2)

    def __reduce__(self):
    # ensures that instances can be pickled
        def iterfun(inst):
           for i, prop in enumerate(inst.properties.values()):
               if isinstance(prop, np.ndarray):
                   p = np.zeros_like(prop)
                   p.flat = [p.asdict() if hasattr(p, 'asdict') else p
                             for p in prop]
               else:
                   p = prop.asdict() if hasattr(prop, 'asdict') else prop
               yield i, p
        return (
            Instance,
            (self.meta.uri, list(self.dimensions.values()), self.uuid),
            None,
            None,
            iterfun(self),
        )

    def __call__(self, dims=(), id=None):
        """Returns an uninitiated instance of this metadata."""
        if not self.is_meta:
            raise TypeError('data instances are not callable')
        return Instance(self.uri, dims, id)

    def asdict(self):
        """Returns a dict representation of self."""
        d = OrderedDict()
        d['uuid'] = self.uuid
        d['meta'] = self.meta.uri
        if self.uri:
            d['uri'] = self.uri
        if self.iri:
            d['iri'] = self.iri
        if self.is_meta:
            d['name'] = self['name']
            d['version'] = self['version']
            d['namespace'] = self['namespace']
            d['description'] = self['description']
            d['dimensions'] = [dim.asdict() for dim in self['dimensions']]
            d['properties'] = [p.asdict() for p in self['properties']]
        else:
            d['dimensions'] = self.dimensions
            d['properties'] = {k: standardise(v)
                               for k, v in self.properties.items()}
        if self.has_property('relations') and (
                self.is_meta or self.meta.has_property('relations')):
            d['relations'] = self['relations'].tolist()
        return d

    def asjson(self, **kwargs):
        """Returns a JSON representation of self.  Arguments are passed to
        json.dumps()."""
        return json.dumps(self.asdict(), cls=InstanceEncoder, **kwargs)


# Register Instance in _dlite:
_dlite.Instance_swigregister(Instance)


def get_instance(id: "char const *", metaid: "char const *"=None, check_storages: "bool"=True) -> "struct _DLiteInstance *":
    r"""
    get_instance(id, metaid=None, check_storages=True) -> Instance
    Returns a new reference to instance with given id.

    If `metaid` is provided, the instance will be mapped to an instance of
    this metadata.

    If the instance exists in the in-memory store it is returned.
    Otherwise, if `check_storages` is true, the instance is searched for
    in the storage plugin path (initiated from the DLITE_STORAGES
    environment variable).

    It is an error message if the instance cannot be found.

    """
    return _dlite.get_instance(id, metaid, check_storages)

def has_instance(id: "char const *", check_storages: "bool"=True) -> "bool":
    r"""
    has_instance(id, check_storages=True) -> bool
    Returns whether an instance with `id` exists.

    If `check_storages` is true, the instance is also searched for
    in the storage plugin path.

    """
    return _dlite.has_instance(id, check_storages)

def _get_property(inst: "Instance", name: "char const *") -> "obj_t *":
    r"""_get_property(inst, name) -> obj_t *"""
    return _dlite._get_property(inst, name)

def _set_property(inst: "Instance", name: "char const *", obj: "obj_t *") -> "void":
    r"""_set_property(inst, name, obj)"""
    return _dlite._set_property(inst, name, obj)

def _has_property(inst: "Instance", name: "char const *") -> "bool":
    r"""_has_property(inst, name) -> bool"""
    return _dlite._has_property(inst, name)
BASIC_METADATA_SCHEMA = _dlite.BASIC_METADATA_SCHEMA

ENTITY_SCHEMA = _dlite.ENTITY_SCHEMA

COLLECTION_ENTITY = _dlite.COLLECTION_ENTITY


import sys
import json
import base64

from uuid import UUID
if sys.version_info >= (3, 7):
    OrderedDict = dict
else:
    from collections import OrderedDict

import numpy as np

class InstanceEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, bytearray):
            return base64.b16encode(obj).decode()
        elif isinstance(obj, bytes):
            return obj.decode()
        elif isinstance(obj, np.ndarray):
            if obj.dtype.kind == 'V':
                conv = lambda e: ([conv(ele) for ele in e]
                                  if isinstance(e, list)
                                  else base64.b16encode(e))
                return conv(obj.tolist())
            else:
                return obj.tolist()
        elif hasattr(obj, 'aspreferred'):
            return obj.aspreferred()
        elif hasattr(obj, 'asdict'):
            return obj.asdict()
        elif hasattr(obj, 'asstrings'):
            return obj.asstrings()
        else:
            return json.JSONEncoder.default(self, obj)


def standardise(v, asdict=True):
    """Represent property value `v` as a standard python type.
    If `asdict` is true, dimensions, properties and relations will be
    represented with a dict, otherwise as a list of strings."""
    if asdict:
        conv = lambda x: x.asdict() if hasattr(x, 'asdict') else x
    else:
        conv = lambda x: list(x.asstrings()) if hasattr(x, 'asstrings') else x

    if hasattr(v, 'tolist'):
        return [conv(x) for x in v.tolist()]
    else:
        return conv(v)


class CollectionIter(object):
    r"""Proxy of C _CollectionIter struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    coll = property(_dlite.CollectionIter_coll_get, _dlite.CollectionIter_coll_set, doc=r"""coll""")
    state = property(_dlite.CollectionIter_state_get, _dlite.CollectionIter_state_set, doc=r"""state""")
    __swig_destroy__ = _dlite.delete_CollectionIter

    def next(self) -> "struct _DLiteInstance *":
        r"""
        next(self) -> Instance
            Returns a reference to next instance.

        """
        return _dlite.CollectionIter_next(self)

    def find(self, s: "char const *"=None, p: "char const *"=None, o: "char const *"=None) -> "struct _Triple const *":
        r"""find(self, s=None, p=None, o=None) -> Relation"""
        return _dlite.CollectionIter_find(self, s, p, o)

    def poll(self) -> "struct _Triple const *":
        r"""
        poll(self) -> Relation
            Returns reference to the current instance or None if all instances have
            been visited.

        """
        return _dlite.CollectionIter_poll(self)

    def reset(self) -> "void":
        r"""
        reset(self)
            Resets the iterator.  The next call to next() will return the first
            instance.

        """
        return _dlite.CollectionIter_reset(self)

    def __iter__(self):
        return self

    def __next__(self):
        next = self.next()
        if next is None:
            raise StopIteration()
        return next


    def __init__(self):
        r"""
        __init__(self) -> CollectionIter
          Iterator over instances in a collection.

        """
        _dlite.CollectionIter_swiginit(self, _dlite.new_CollectionIter())

# Register CollectionIter in _dlite:
_dlite.CollectionIter_swigregister(CollectionIter)

class Collection(object):
    r"""Proxy of C _DLiteCollection struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uuid = property(_dlite.Collection_uuid_get, doc=r"""uuid""")
    uri = property(_dlite.Collection_uri_get, doc=r"""uri""")
    _refcount = property(_dlite.Collection__refcount_get, doc=r"""_refcount""")

    def __init__(self, *args):
        r"""
        __init__(self, id=None) -> Collection
        __init__(self, storage, id, lazy=0) -> Collection
        __init__(self, url, lazy) -> Collection
        Returns a collection instance.

        Collection(id=None)
            Creates a new empty collection with the given `id`.  The id may be any
            string uniquely identifying this collection.

        Collection(storage, id, lazy=0)
            Loads collection with given `id` from `storage`.  If `lazy` is zero,
            all its instances are loaded immediately.  Otherwise, instances are
            first loaded on demand.

        Collection(url, lazy)
            Loads collection from `url`, which should be of the form
            ``driver://location?options#id``.  The `lazy` argument has the same
            meaning as above.


        """
        _dlite.Collection_swiginit(self, _dlite.new_Collection(*args))
    __swig_destroy__ = _dlite.delete_Collection

    def save(self, *args) -> "void":
        r"""
        save(self, storage)
        save(self, url)
        save(self, driver, path, options=None)
        Saves this instance to url or storage.
        """
        return _dlite.Collection_save(self, *args)

    def add_relation(self, *args) -> "void":
        r"""
        add_relation(self, s, p, o)
        add_relation(self, t)
        Adds (subject, predicate, object) relation to the collection.
        """
        return _dlite.Collection_add_relation(self, *args)

    def get_meta(self) -> "struct _DLiteInstance const *":
        r"""
        get_meta(self) -> Instance
        Returns reference to metadata.
        """
        return _dlite.Collection_get_meta(self)

    def asinstance(self) -> "struct _DLiteInstance *":
        r"""
        asinstance(self) -> Instance
        Returns a new view of self as an instance.
        """
        return _dlite.Collection_asinstance(self)

    def remove_relations(self, s: "char const *"=None, p: "char const *"=None, o: "char const *"=None) -> "void":
        r"""
        remove_relations(self, s=None, p=None, o=None)
          Removes all relations matching the provided subject `s`, predicate `p`
          and object `o`.  If any of `s`, `p` and/or `o` are None, they works as
          a wildcard.

        """
        return _dlite.Collection_remove_relations(self, s, p, o)

    def find_first(self, s: "char const *"=None, p: "char const *"=None, o: "char const *"=None) -> "struct _Triple const *":
        r"""
        find_first(self, s=None, p=None, o=None) -> Relation
          Returns the first relation matching the provided subject `s`, predicate
          `p` and object `o`.  If any of `s`, `p` and/or `o` are None, they works
          as a wildcard.

        """
        return _dlite.Collection_find_first(self, s, p, o)

    def get_iter(self) -> "struct _CollectionIter *":
        r"""
        get_iter(self) -> CollectionIter
          Returns an iterator for iterating over instances.

        """
        return _dlite.Collection_get_iter(self)

    def add(self, label: "char const *", inst: "Instance") -> "void":
        r"""
        add(self, label, inst)
        Adds instance `inst` to the collection.
        """
        return _dlite.Collection_add(self, label, inst)

    def remove(self, label: "char const *") -> "void":
        r"""
        remove(self, label)
        Removes instance with given label from collection.
        """
        return _dlite.Collection_remove(self, label)

    def get(self, label: "char const *", metaid: "char const *"=None) -> "struct _DLiteInstance *":
        r"""
        get(self, label, metaid=None) -> Instance
            Returns instance corresponding to `label`.  If `metaid` is provided,
            the returned instance will be mapped to an instance of this metadata.
            Returns NULL on error.

        """
        return _dlite.Collection_get(self, label, metaid)

    def get_id(self, id: "char const *") -> "struct _DLiteInstance *":
        r"""
        get_id(self, id) -> Instance
          Returns a reference to instance with given id or None on error.

        """
        return _dlite.Collection_get_id(self, id)

    def has(self, label: "char const *") -> "bool":
        r"""
        has(self, label) -> bool
          Returns true if the collection contains a reference with the given label.

        """
        return _dlite.Collection_has(self, label)

    def has_id(self, id: "char const *") -> "bool":
        r"""
        has_id(self, id) -> bool
          Returns true if the collection contains a reference with the given id
          (URI or UUID).

        """
        return _dlite.Collection_has_id(self, id)

    def count(self) -> "int":
        r"""
        count(self) -> int
          Returns number of instances in the collection.

        """
        return _dlite.Collection_count(self)

    def incref(self) -> "int":
        r"""
        incref(self) -> int
          Increase reference count and return the new refcount.

        """
        return _dlite.Collection_incref(self)

    def decref(self) -> "int":
        r"""
        decref(self) -> int
          Decrease reference count and return the new refcount.

        """
        return _dlite.Collection_decref(self)

    def __repr__(self):
        return "Collection(%r)" % (self.uri if self.uri else self.uuid)

    def __str__(self):
        return str(self.asinstance())

    def __iter__(self):
        return self.get_iter()

    def __getitem__(self, label):
        return self.get(label)

    def __setitem__(self, label, inst):
        self.add(label, inst)

    def __delitem__(self, label):
        self.remove(label)

    def __len__(self):
        return self.count()

    def __contains__(self, item):
        return self.has(item)

    meta = property(get_meta, doc='Reference to metadata of this collection.')

    def asdict(self):
        """Returns a dict representation of self."""
        return self.asinstance().asdict()

    def asjson(self, **kwargs):
        """Returns a JSON-representation of self. Arguments are passed to
        json.dumps()."""
        return self.asinstance().asjson()

    def get_relations(self, s=None, p=None, o=None):
        """Returns a generator over all relations matching the given
        values of `s`, `p` and `o`."""
        itr = self.get_iter()
        while itr.poll():
            yield itr.find(s, p, o)

    def get_instances(self):
        """Returns a generator over all instances in this collection."""
        itr = self.get_iter()
        while itr.poll():
            yield itr.next()



# Register Collection in _dlite:
_dlite.Collection_swigregister(Collection)


def get_collection(id: "char const *") -> "struct _DLiteCollection *":
    r"""
    get_collection(id) -> Collection
    Returns a new reference to a collection with given id.

    """
    return _dlite.get_collection(id)
class FUPath(object):
    r"""Proxy of C _FUPaths struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    n = property(_dlite.FUPath_n_get, doc=r"""n""")

    def __init__(self, pathtype: "char const *"):
        r"""
        __init__(self, pathtype) -> FUPath
        Creates a _Path instance of type `pathtype`.

        """
        _dlite.FUPath_swiginit(self, _dlite.new_FUPath(pathtype))
    __swig_destroy__ = _dlite.delete_FUPath

    def __repr__(self) -> "char *":
        r"""__repr__(self) -> char *"""
        return _dlite.FUPath___repr__(self)

    def __len__(self) -> "int":
        r"""__len__(self) -> int"""
        return _dlite.FUPath___len__(self)

    def getitem(self, index: "int") -> "char const *":
        r"""getitem(self, index) -> char const *"""
        return _dlite.FUPath_getitem(self, index)

    def __setitem__(self, index: "int", path: "char const *") -> "void":
        r"""__setitem__(self, index, path)"""
        return _dlite.FUPath___setitem__(self, index, path)

    def __delitem__(self, index: "int") -> "void":
        r"""__delitem__(self, index)"""
        return _dlite.FUPath___delitem__(self, index)

    def insert(self, index: "int", path: "char const *") -> "void":
        r"""insert(self, index, path)"""
        return _dlite.FUPath_insert(self, index, path)

    def append(self, path: "char const *") -> "void":
        r"""append(self, path)"""
        return _dlite.FUPath_append(self, path)

    def extend(self, paths: "char const *", pathsep: "char const *"=None) -> "void":
        r"""extend(self, paths, pathsep=None)"""
        return _dlite.FUPath_extend(self, paths, pathsep)

    def get_platform(self) -> "char const *":
        r"""get_platform(self) -> char const *"""
        return _dlite.FUPath_get_platform(self)

    def set_platform(self, platform: "char const *") -> "void":
        r"""set_platform(self, platform)"""
        return _dlite.FUPath_set_platform(self, platform)

    def __contains__(self, value):
        return value in self.aslist()

    def __getitem__(self, key):
        n = len(self)
        if key < 0:
            key += n
        if key < 0 or key >= n:
            raise IndexError(f'key out of range: {key}')
        return self.getitem(key)

    def aslist(self):
        return [self[i] for i in range(len(self))]



# Register FUPath in _dlite:
_dlite.FUPath_swigregister(FUPath)


storage_path = FUPath("storages")
storage_plugin_path = FUPath("storage-plugins")
mapping_plugin_path = FUPath("mapping-plugins")
python_storage_plugin_path = FUPath("python-storage-plugins")
python_mapping_plugin_path = FUPath("python-mapping-plugins")



def mapping(output_uri: "char const *", instances: "struct _DLiteInstance **") -> "struct _DLiteInstance *":
    r"""
    mapping(output_uri, instances) -> Instance
      Returns a new instance of metadata `output_uri` by mapping the
      input instances.

    """
    return _dlite.mapping(output_uri, instances)

def python_mapping_unload() -> "void":
    r"""
    python_mapping_unload()
      Unloads all currently loaded mappings.

    """
    return _dlite.python_mapping_unload()

def mapping_plugin_unload(name: "char const *"=None) -> "int":
    r"""mapping_plugin_unload(name=None) -> int"""
    return _dlite.mapping_plugin_unload(name)


